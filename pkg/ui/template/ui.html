<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Bully election algorithm</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
</head>

<body class="vh-100 d-flex flex-column flex-nowrap">
    <main>
        <ul class="m-3">
            <li>Total disruptions: <span id="total-disruptions"></span></li>
            <li>Mean disruption duration: <span id="mean-disruption-duration"></span></li>
            <li>Max disruption duration: <span id="max-disruption-duration"></span></li>
            <li>Total disruption duration: <span id="total-disruption-duration"></span></li>
        </ul>

        <ul class="m-3">
            <li>Total unavailable times: <span id="total-unavailable"></span></li>
            <li>Mean unavailable duration: <span id="mean-unavailable-duration"></span></li>
            <li>Max unavailable duration: <span id="max-unavailable-duration"></span></li>
            <li>Total unavailable duration: <span id="total-unavailable-duration"></span></li>
        </ul>

        <div id="container" class="d-flex flex-row flex-wrap gap-2 p-4 justify-content-center">
            <div id="prototype" class="card shadow-sm mw-20em">
                <div class="card-body position-relative">
                    <h3 class="h3 card-title">Replica name</h3>
                    <p class="card-subtitle">Replica role</p>
                    <p class="card-subtitle">Replica state</p>
                    <p class="card-subtitle">Replica leader</p>
                </div>

                <div class="card-footer">
                    <span class="badge">Correct role</span>
                    <span class="badge">Correct leader</span>
                </div>
            </div>
        </div>
    </main>

    <footer class="mt-auto text-center p-2">
        <span class="text-muted">host: {{ .Hostname }},</span>
        <span class="text-muted">namespace: {{ .Namespace }}</span>
    </footer>

    <style>
        .mw-20em {
            max-width: 20em;
        }

    </style>

    <script>
        async function fetchState() {
            let url = ''
            if (document.location.protocol === 'file:') {
                url = 'http://localhost:80'
            } else {
                url = `${document.location.origin}:80`
            }

            const response = await fetch(url)
            if (!response.ok) {
                throw Error(`Response has incorrect status code: ${response.statusText}`)
            }

            const { data, error } = await response.json()
            if (error) {
                throw Error(`Backend returned error: ${error}`)
            }

            return data
        }

        function setClasses(element, conditions, fallback = null) {
            let matched = false
            for (const [className, condition] of Object.entries(conditions)) {
                if (condition) {
                    element.classList.add(className)
                    matched = true
                } else {
                    element.classList.remove(className)
                }
            }

            if (!matched && fallback) {
                element.classList.add(fallback)
            } else {
                element.classList.remove(fallback)
            }
        }

        function createCard(container, prototype) {
            const card = prototype.cloneNode(true)
            card.removeAttribute('id')
            container.appendChild(card)
            return card
        }

        function fillCard(card, replica, leader) {
            const isLeader = replica.name === leader

            setClasses(card, {
                'border-5': isLeader,
                'border-primary': isLeader
            })

            const cardBody = card.children[0]

            cardBody.children[0].textContent = replica.name ?? '<Name not available>'
            cardBody.children[1].textContent = replica.role ?? '<Role not available>'
            cardBody.children[2].textContent = replica.state ?? '<State not available>'
            cardBody.children[3].textContent = replica.leader ?? '<Leader not available>'

            const cardFooter = card.children[1]

            // Whether replica considers itself elected or not.
            const leaderRole = replica.role === 'leader'
            const replicaRole = replica.role === 'replica'

            setClasses(cardFooter.children[0], {
                // Replica is in a correct final state.
                'bg-success': leaderRole && isLeader || replicaRole && !isLeader,
                // Replica isn't in a correct final state.
                'bg-danger': leaderRole && !isLeader || replicaRole && isLeader
            }, 'bg-warning')

            setClasses(cardFooter.children[1], {
                'bg-success': replica.leader === leader
            }, 'bg-danger')

            return card
        }

        function updateMetrics(metrics, state) {
            for (const replica of state.replicas) {
                if (typeof replica.leader === 'string'
                    && replica.leader !== state.leader
                    && !metrics.disruptions.isStarted(replica.name)) {
                        console.debug(`Disruption started for replica ${replica.name}`)
                        metrics.disruptions.start(replica.name)
                } else if (replica.leader === state.leader
                    && metrics.disruptions.isStarted(replica.name)) {
                        console.debug(`Disruption ended for replica ${replica.name}`)
                        metrics.disruptions.end(replica.name)
                    }

                if (typeof replica.leader !== 'string'
                    && !metrics.unavailable.isStarted(replica.name)) {
                    console.debug(`Unavailable period started for replica ${replica.name}`)
                    metrics.unavailable.start(replica.name)
                } else if (typeof replica.leader === 'string'
                    && metrics.unavailable.isStarted(replica.name)) {
                    console.debug(`Unavailable period ended for replica ${replica.name}`)
                    metrics.unavailable.end(replica.name)
                }
            }

            metrics.refresh()
        }

        function updateState(cards, container, prototype, metrics) {
            const onReject = error => {
                console.error(error)

                // Hide all cards.
                cards.forEach((card, index) => setClasses(card, {
                    'collapse': true
                }))
            }

            fetchState().then(state => {
                if (!state || !state.replicas || !state.leader) {
                    throw Error('Invalid state provided: ${state}')
                }

                // Descending sort on names.
                state.replicas.sort((a, b) => a.name < b.name ? 1 : a.name > b.name ? -1 : 0)

                // Create missing cards.
                for (let index = cards.length; index < state.replicas.length; index++) {
                    cards.push(createCard(container, prototype))
                }

                // Hide extra cards.
                cards.forEach((card, index) => setClasses(card, {
                    'collapse': index >= state.replicas.length
                }))

                // Fill replica cards.
                state.replicas.forEach((replica, index) => fillCard(cards[index], replica, state.leader));

                updateMetrics(metrics, state)
            }, onReject).then(() => {
                setTimeout(() => updateState(cards, container, prototype, metrics), 1000)
            }, onReject)
        }

        const container = document.getElementById('container')
        const prototype = document.getElementById('prototype')
        prototype.remove()

        const cards = []

        const createMetric = () => ({
            started: [],
            finished: [],
            start(replica) {
                this.started.push({
                    replica: replica,
                    startDate: new Date(),
                    endDate: null,
                    duration() {
                        return (this.endDate - this.startDate) / 1000
                    }
                })
            },
            end(replica) {
                const index = this.started.findIndex(x => x.replica === replica)
                const x = this.started.pop(index)
                x.endDate = new Date()
                this.finished.push(x)
            },
            isStarted(replica) {
                return this.started.find(x => x.replica === replica) !== undefined
            },
            meanDuration() {
                if (this.finished.length > 0) {
                    return this.totalDuration() / this.finished.length
                } else {
                    return 0
                }
            },
            maxDuration() {
                if (this.finished.length > 0) {
                    return this.finished
                        .map(x => x.duration())
                        .reduce((x, y) => Math.max(x, y))
                } else {
                    return 0
                }
            },
            totalDuration() {
                if (this.finished.length > 0) {
                    return this.finished
                        .map(x => x.duration())
                        .reduce((x, y) => x + y)
                } else {
                    return 0
                }
            }
        })

        const metrics = {
            totalDisruptionsElement: document.getElementById('total-disruptions'),
            meanDisruptionDurationElement: document.getElementById('mean-disruption-duration'),
            maxDisruptionDurationElement: document.getElementById('max-disruption-duration'),
            totalDisruptionDurationElement: document.getElementById('total-disruption-duration'),

            totalUnavailableElement: document.getElementById('total-unavailable'),
            meanUnavailableDurationElement: document.getElementById('mean-unavailable-duration'),
            maxUnavailableDurationElement: document.getElementById('max-unavailable-duration'),
            totalUnavailableDurationElement: document.getElementById('total-unavailable-duration'),

            refresh() {
                this.totalDisruptionsElement.innerText = `${this.disruptions.started.length} | ${this.disruptions.finished.length} times (started | finished)`
                this.meanDisruptionDurationElement.innerText = `${this.disruptions.meanDuration()}s`
                this.maxDisruptionDurationElement.innerText = `${this.disruptions.maxDuration()}s`
                this.totalDisruptionDurationElement.innerText = `${this.disruptions.totalDuration()}s`

                this.totalUnavailableElement.innerText = `${this.unavailable.started.length} | ${this.unavailable.finished.length} times (started | finished)`
                this.meanUnavailableDurationElement.innerText = `${this.unavailable.meanDuration()}s`
                this.maxUnavailableDurationElement.innerText = `${this.unavailable.maxDuration()}s`
                this.totalUnavailableDurationElement.innerText = `${this.unavailable.totalDuration()}s`
            },

            disruptions: createMetric(),
            unavailable: createMetric()
        }

        updateState(cards, container, prototype, metrics)
    </script>
</body>

</html>
